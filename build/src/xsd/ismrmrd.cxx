// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ismrmrd.hxx"

namespace ISMRMRD
{
  // subjectInformationType
  // 

  const subjectInformationType::patientName_optional& subjectInformationType::
  patientName () const
  {
    return this->patientName_;
  }

  subjectInformationType::patientName_optional& subjectInformationType::
  patientName ()
  {
    return this->patientName_;
  }

  void subjectInformationType::
  patientName (const patientName_type& x)
  {
    this->patientName_.set (x);
  }

  void subjectInformationType::
  patientName (const patientName_optional& x)
  {
    this->patientName_ = x;
  }

  void subjectInformationType::
  patientName (::std::auto_ptr< patientName_type > x)
  {
    this->patientName_.set (x);
  }

  const subjectInformationType::patientWeight_kg_optional& subjectInformationType::
  patientWeight_kg () const
  {
    return this->patientWeight_kg_;
  }

  subjectInformationType::patientWeight_kg_optional& subjectInformationType::
  patientWeight_kg ()
  {
    return this->patientWeight_kg_;
  }

  void subjectInformationType::
  patientWeight_kg (const patientWeight_kg_type& x)
  {
    this->patientWeight_kg_.set (x);
  }

  void subjectInformationType::
  patientWeight_kg (const patientWeight_kg_optional& x)
  {
    this->patientWeight_kg_ = x;
  }


  // experimentalConditionsType
  // 

  const experimentalConditionsType::H1resonanceFrequencyHz_type& experimentalConditionsType::
  H1resonanceFrequencyHz () const
  {
    return this->H1resonanceFrequencyHz_.get ();
  }

  experimentalConditionsType::H1resonanceFrequencyHz_type& experimentalConditionsType::
  H1resonanceFrequencyHz ()
  {
    return this->H1resonanceFrequencyHz_.get ();
  }

  void experimentalConditionsType::
  H1resonanceFrequencyHz (const H1resonanceFrequencyHz_type& x)
  {
    this->H1resonanceFrequencyHz_.set (x);
  }


  // acquisitionSystemInformationType
  // 

  const acquisitionSystemInformationType::systemVendor_optional& acquisitionSystemInformationType::
  systemVendor () const
  {
    return this->systemVendor_;
  }

  acquisitionSystemInformationType::systemVendor_optional& acquisitionSystemInformationType::
  systemVendor ()
  {
    return this->systemVendor_;
  }

  void acquisitionSystemInformationType::
  systemVendor (const systemVendor_type& x)
  {
    this->systemVendor_.set (x);
  }

  void acquisitionSystemInformationType::
  systemVendor (const systemVendor_optional& x)
  {
    this->systemVendor_ = x;
  }

  void acquisitionSystemInformationType::
  systemVendor (::std::auto_ptr< systemVendor_type > x)
  {
    this->systemVendor_.set (x);
  }

  const acquisitionSystemInformationType::systemModel_optional& acquisitionSystemInformationType::
  systemModel () const
  {
    return this->systemModel_;
  }

  acquisitionSystemInformationType::systemModel_optional& acquisitionSystemInformationType::
  systemModel ()
  {
    return this->systemModel_;
  }

  void acquisitionSystemInformationType::
  systemModel (const systemModel_type& x)
  {
    this->systemModel_.set (x);
  }

  void acquisitionSystemInformationType::
  systemModel (const systemModel_optional& x)
  {
    this->systemModel_ = x;
  }

  void acquisitionSystemInformationType::
  systemModel (::std::auto_ptr< systemModel_type > x)
  {
    this->systemModel_.set (x);
  }

  const acquisitionSystemInformationType::systemFieldStrength_T_optional& acquisitionSystemInformationType::
  systemFieldStrength_T () const
  {
    return this->systemFieldStrength_T_;
  }

  acquisitionSystemInformationType::systemFieldStrength_T_optional& acquisitionSystemInformationType::
  systemFieldStrength_T ()
  {
    return this->systemFieldStrength_T_;
  }

  void acquisitionSystemInformationType::
  systemFieldStrength_T (const systemFieldStrength_T_type& x)
  {
    this->systemFieldStrength_T_.set (x);
  }

  void acquisitionSystemInformationType::
  systemFieldStrength_T (const systemFieldStrength_T_optional& x)
  {
    this->systemFieldStrength_T_ = x;
  }


  // encodingSpaceType
  // 

  const encodingSpaceType::matrixSize_type& encodingSpaceType::
  matrixSize () const
  {
    return this->matrixSize_.get ();
  }

  encodingSpaceType::matrixSize_type& encodingSpaceType::
  matrixSize ()
  {
    return this->matrixSize_.get ();
  }

  void encodingSpaceType::
  matrixSize (const matrixSize_type& x)
  {
    this->matrixSize_.set (x);
  }

  void encodingSpaceType::
  matrixSize (::std::auto_ptr< matrixSize_type > x)
  {
    this->matrixSize_.set (x);
  }

  const encodingSpaceType::fieldOfView_m_type& encodingSpaceType::
  fieldOfView_m () const
  {
    return this->fieldOfView_m_.get ();
  }

  encodingSpaceType::fieldOfView_m_type& encodingSpaceType::
  fieldOfView_m ()
  {
    return this->fieldOfView_m_.get ();
  }

  void encodingSpaceType::
  fieldOfView_m (const fieldOfView_m_type& x)
  {
    this->fieldOfView_m_.set (x);
  }

  void encodingSpaceType::
  fieldOfView_m (::std::auto_ptr< fieldOfView_m_type > x)
  {
    this->fieldOfView_m_.set (x);
  }


  // limitType
  // 

  const limitType::minimum_type& limitType::
  minimum () const
  {
    return this->minimum_.get ();
  }

  limitType::minimum_type& limitType::
  minimum ()
  {
    return this->minimum_.get ();
  }

  void limitType::
  minimum (const minimum_type& x)
  {
    this->minimum_.set (x);
  }

  limitType::minimum_type limitType::
  minimum_default_value ()
  {
    return minimum_type (0);
  }

  const limitType::maximum_type& limitType::
  maximum () const
  {
    return this->maximum_.get ();
  }

  limitType::maximum_type& limitType::
  maximum ()
  {
    return this->maximum_.get ();
  }

  void limitType::
  maximum (const maximum_type& x)
  {
    this->maximum_.set (x);
  }

  limitType::maximum_type limitType::
  maximum_default_value ()
  {
    return maximum_type (0);
  }

  const limitType::center_type& limitType::
  center () const
  {
    return this->center_.get ();
  }

  limitType::center_type& limitType::
  center ()
  {
    return this->center_.get ();
  }

  void limitType::
  center (const center_type& x)
  {
    this->center_.set (x);
  }

  limitType::center_type limitType::
  center_default_value ()
  {
    return center_type (0);
  }


  // encodingLimitsType
  // 

  const encodingLimitsType::kspace_encoding_step_1_optional& encodingLimitsType::
  kspace_encoding_step_1 () const
  {
    return this->kspace_encoding_step_1_;
  }

  encodingLimitsType::kspace_encoding_step_1_optional& encodingLimitsType::
  kspace_encoding_step_1 ()
  {
    return this->kspace_encoding_step_1_;
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (const kspace_encoding_step_1_type& x)
  {
    this->kspace_encoding_step_1_.set (x);
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (const kspace_encoding_step_1_optional& x)
  {
    this->kspace_encoding_step_1_ = x;
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (::std::auto_ptr< kspace_encoding_step_1_type > x)
  {
    this->kspace_encoding_step_1_.set (x);
  }

  const encodingLimitsType::kspace_encoding_step_2_optional& encodingLimitsType::
  kspace_encoding_step_2 () const
  {
    return this->kspace_encoding_step_2_;
  }

  encodingLimitsType::kspace_encoding_step_2_optional& encodingLimitsType::
  kspace_encoding_step_2 ()
  {
    return this->kspace_encoding_step_2_;
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (const kspace_encoding_step_2_type& x)
  {
    this->kspace_encoding_step_2_.set (x);
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (const kspace_encoding_step_2_optional& x)
  {
    this->kspace_encoding_step_2_ = x;
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (::std::auto_ptr< kspace_encoding_step_2_type > x)
  {
    this->kspace_encoding_step_2_.set (x);
  }

  const encodingLimitsType::average_optional& encodingLimitsType::
  average () const
  {
    return this->average_;
  }

  encodingLimitsType::average_optional& encodingLimitsType::
  average ()
  {
    return this->average_;
  }

  void encodingLimitsType::
  average (const average_type& x)
  {
    this->average_.set (x);
  }

  void encodingLimitsType::
  average (const average_optional& x)
  {
    this->average_ = x;
  }

  void encodingLimitsType::
  average (::std::auto_ptr< average_type > x)
  {
    this->average_.set (x);
  }

  const encodingLimitsType::slice_optional& encodingLimitsType::
  slice () const
  {
    return this->slice_;
  }

  encodingLimitsType::slice_optional& encodingLimitsType::
  slice ()
  {
    return this->slice_;
  }

  void encodingLimitsType::
  slice (const slice_type& x)
  {
    this->slice_.set (x);
  }

  void encodingLimitsType::
  slice (const slice_optional& x)
  {
    this->slice_ = x;
  }

  void encodingLimitsType::
  slice (::std::auto_ptr< slice_type > x)
  {
    this->slice_.set (x);
  }

  const encodingLimitsType::contrast_optional& encodingLimitsType::
  contrast () const
  {
    return this->contrast_;
  }

  encodingLimitsType::contrast_optional& encodingLimitsType::
  contrast ()
  {
    return this->contrast_;
  }

  void encodingLimitsType::
  contrast (const contrast_type& x)
  {
    this->contrast_.set (x);
  }

  void encodingLimitsType::
  contrast (const contrast_optional& x)
  {
    this->contrast_ = x;
  }

  void encodingLimitsType::
  contrast (::std::auto_ptr< contrast_type > x)
  {
    this->contrast_.set (x);
  }

  const encodingLimitsType::phase_optional& encodingLimitsType::
  phase () const
  {
    return this->phase_;
  }

  encodingLimitsType::phase_optional& encodingLimitsType::
  phase ()
  {
    return this->phase_;
  }

  void encodingLimitsType::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void encodingLimitsType::
  phase (const phase_optional& x)
  {
    this->phase_ = x;
  }

  void encodingLimitsType::
  phase (::std::auto_ptr< phase_type > x)
  {
    this->phase_.set (x);
  }

  const encodingLimitsType::repetition_optional& encodingLimitsType::
  repetition () const
  {
    return this->repetition_;
  }

  encodingLimitsType::repetition_optional& encodingLimitsType::
  repetition ()
  {
    return this->repetition_;
  }

  void encodingLimitsType::
  repetition (const repetition_type& x)
  {
    this->repetition_.set (x);
  }

  void encodingLimitsType::
  repetition (const repetition_optional& x)
  {
    this->repetition_ = x;
  }

  void encodingLimitsType::
  repetition (::std::auto_ptr< repetition_type > x)
  {
    this->repetition_.set (x);
  }

  const encodingLimitsType::set_optional& encodingLimitsType::
  set () const
  {
    return this->set_;
  }

  encodingLimitsType::set_optional& encodingLimitsType::
  set ()
  {
    return this->set_;
  }

  void encodingLimitsType::
  set (const set_type& x)
  {
    this->set_.set (x);
  }

  void encodingLimitsType::
  set (const set_optional& x)
  {
    this->set_ = x;
  }

  void encodingLimitsType::
  set (::std::auto_ptr< set_type > x)
  {
    this->set_.set (x);
  }

  const encodingLimitsType::segment_optional& encodingLimitsType::
  segment () const
  {
    return this->segment_;
  }

  encodingLimitsType::segment_optional& encodingLimitsType::
  segment ()
  {
    return this->segment_;
  }

  void encodingLimitsType::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void encodingLimitsType::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void encodingLimitsType::
  segment (::std::auto_ptr< segment_type > x)
  {
    this->segment_.set (x);
  }


  // trajectoryType
  // 

  trajectoryType::
  trajectoryType (value v)
  : ::xml_schema::string (_xsd_trajectoryType_literals_[v])
  {
  }

  trajectoryType::
  trajectoryType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const trajectoryType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  trajectoryType& trajectoryType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_trajectoryType_literals_[v]);

    return *this;
  }


  // userParameterLongType
  // 

  const userParameterLongType::name_type& userParameterLongType::
  name () const
  {
    return this->name_.get ();
  }

  userParameterLongType::name_type& userParameterLongType::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterLongType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterLongType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterLongType::value_type& userParameterLongType::
  value () const
  {
    return this->value_.get ();
  }

  userParameterLongType::value_type& userParameterLongType::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterLongType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // userParameterDoubleType
  // 

  const userParameterDoubleType::name_type& userParameterDoubleType::
  name () const
  {
    return this->name_.get ();
  }

  userParameterDoubleType::name_type& userParameterDoubleType::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterDoubleType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterDoubleType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterDoubleType::value_type& userParameterDoubleType::
  value () const
  {
    return this->value_.get ();
  }

  userParameterDoubleType::value_type& userParameterDoubleType::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterDoubleType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // ismrmrdHeader
  // 

  const ismrmrdHeader::subjectInformation_optional& ismrmrdHeader::
  subjectInformation () const
  {
    return this->subjectInformation_;
  }

  ismrmrdHeader::subjectInformation_optional& ismrmrdHeader::
  subjectInformation ()
  {
    return this->subjectInformation_;
  }

  void ismrmrdHeader::
  subjectInformation (const subjectInformation_type& x)
  {
    this->subjectInformation_.set (x);
  }

  void ismrmrdHeader::
  subjectInformation (const subjectInformation_optional& x)
  {
    this->subjectInformation_ = x;
  }

  void ismrmrdHeader::
  subjectInformation (::std::auto_ptr< subjectInformation_type > x)
  {
    this->subjectInformation_.set (x);
  }

  const ismrmrdHeader::acquisitionSystemInformation_optional& ismrmrdHeader::
  acquisitionSystemInformation () const
  {
    return this->acquisitionSystemInformation_;
  }

  ismrmrdHeader::acquisitionSystemInformation_optional& ismrmrdHeader::
  acquisitionSystemInformation ()
  {
    return this->acquisitionSystemInformation_;
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (const acquisitionSystemInformation_type& x)
  {
    this->acquisitionSystemInformation_.set (x);
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (const acquisitionSystemInformation_optional& x)
  {
    this->acquisitionSystemInformation_ = x;
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (::std::auto_ptr< acquisitionSystemInformation_type > x)
  {
    this->acquisitionSystemInformation_.set (x);
  }

  const ismrmrdHeader::experimentalConditions_type& ismrmrdHeader::
  experimentalConditions () const
  {
    return this->experimentalConditions_.get ();
  }

  ismrmrdHeader::experimentalConditions_type& ismrmrdHeader::
  experimentalConditions ()
  {
    return this->experimentalConditions_.get ();
  }

  void ismrmrdHeader::
  experimentalConditions (const experimentalConditions_type& x)
  {
    this->experimentalConditions_.set (x);
  }

  void ismrmrdHeader::
  experimentalConditions (::std::auto_ptr< experimentalConditions_type > x)
  {
    this->experimentalConditions_.set (x);
  }

  const ismrmrdHeader::encoding_sequence& ismrmrdHeader::
  encoding () const
  {
    return this->encoding_;
  }

  ismrmrdHeader::encoding_sequence& ismrmrdHeader::
  encoding ()
  {
    return this->encoding_;
  }

  void ismrmrdHeader::
  encoding (const encoding_sequence& s)
  {
    this->encoding_ = s;
  }

  const ismrmrdHeader::userParameters_optional& ismrmrdHeader::
  userParameters () const
  {
    return this->userParameters_;
  }

  ismrmrdHeader::userParameters_optional& ismrmrdHeader::
  userParameters ()
  {
    return this->userParameters_;
  }

  void ismrmrdHeader::
  userParameters (const userParameters_type& x)
  {
    this->userParameters_.set (x);
  }

  void ismrmrdHeader::
  userParameters (const userParameters_optional& x)
  {
    this->userParameters_ = x;
  }

  void ismrmrdHeader::
  userParameters (::std::auto_ptr< userParameters_type > x)
  {
    this->userParameters_.set (x);
  }


  // matrixSize
  // 

  const matrixSize::x_type& matrixSize::
  x () const
  {
    return this->x_.get ();
  }

  matrixSize::x_type& matrixSize::
  x ()
  {
    return this->x_.get ();
  }

  void matrixSize::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  matrixSize::x_type matrixSize::
  x_default_value ()
  {
    return x_type (1);
  }

  const matrixSize::y_type& matrixSize::
  y () const
  {
    return this->y_.get ();
  }

  matrixSize::y_type& matrixSize::
  y ()
  {
    return this->y_.get ();
  }

  void matrixSize::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  matrixSize::y_type matrixSize::
  y_default_value ()
  {
    return y_type (1);
  }

  const matrixSize::z_type& matrixSize::
  z () const
  {
    return this->z_.get ();
  }

  matrixSize::z_type& matrixSize::
  z ()
  {
    return this->z_.get ();
  }

  void matrixSize::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  matrixSize::z_type matrixSize::
  z_default_value ()
  {
    return z_type (1);
  }


  // fieldOfView_m
  // 

  const fieldOfView_m::x_type& fieldOfView_m::
  x () const
  {
    return this->x_.get ();
  }

  fieldOfView_m::x_type& fieldOfView_m::
  x ()
  {
    return this->x_.get ();
  }

  void fieldOfView_m::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const fieldOfView_m::y_type& fieldOfView_m::
  y () const
  {
    return this->y_.get ();
  }

  fieldOfView_m::y_type& fieldOfView_m::
  y ()
  {
    return this->y_.get ();
  }

  void fieldOfView_m::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const fieldOfView_m::z_type& fieldOfView_m::
  z () const
  {
    return this->z_.get ();
  }

  fieldOfView_m::z_type& fieldOfView_m::
  z ()
  {
    return this->z_.get ();
  }

  void fieldOfView_m::
  z (const z_type& x)
  {
    this->z_.set (x);
  }


  // encoding
  // 

  const encoding::encodedSpace_type& encoding::
  encodedSpace () const
  {
    return this->encodedSpace_.get ();
  }

  encoding::encodedSpace_type& encoding::
  encodedSpace ()
  {
    return this->encodedSpace_.get ();
  }

  void encoding::
  encodedSpace (const encodedSpace_type& x)
  {
    this->encodedSpace_.set (x);
  }

  void encoding::
  encodedSpace (::std::auto_ptr< encodedSpace_type > x)
  {
    this->encodedSpace_.set (x);
  }

  const encoding::reconSpace_type& encoding::
  reconSpace () const
  {
    return this->reconSpace_.get ();
  }

  encoding::reconSpace_type& encoding::
  reconSpace ()
  {
    return this->reconSpace_.get ();
  }

  void encoding::
  reconSpace (const reconSpace_type& x)
  {
    this->reconSpace_.set (x);
  }

  void encoding::
  reconSpace (::std::auto_ptr< reconSpace_type > x)
  {
    this->reconSpace_.set (x);
  }

  const encoding::encodingLimits_type& encoding::
  encodingLimits () const
  {
    return this->encodingLimits_.get ();
  }

  encoding::encodingLimits_type& encoding::
  encodingLimits ()
  {
    return this->encodingLimits_.get ();
  }

  void encoding::
  encodingLimits (const encodingLimits_type& x)
  {
    this->encodingLimits_.set (x);
  }

  void encoding::
  encodingLimits (::std::auto_ptr< encodingLimits_type > x)
  {
    this->encodingLimits_.set (x);
  }

  const encoding::trajectory_type& encoding::
  trajectory () const
  {
    return this->trajectory_.get ();
  }

  encoding::trajectory_type& encoding::
  trajectory ()
  {
    return this->trajectory_.get ();
  }

  void encoding::
  trajectory (const trajectory_type& x)
  {
    this->trajectory_.set (x);
  }

  void encoding::
  trajectory (::std::auto_ptr< trajectory_type > x)
  {
    this->trajectory_.set (x);
  }


  // userParameters
  // 

  const userParameters::userParameterLong_sequence& userParameters::
  userParameterLong () const
  {
    return this->userParameterLong_;
  }

  userParameters::userParameterLong_sequence& userParameters::
  userParameterLong ()
  {
    return this->userParameterLong_;
  }

  void userParameters::
  userParameterLong (const userParameterLong_sequence& s)
  {
    this->userParameterLong_ = s;
  }

  const userParameters::userParameterDouble_sequence& userParameters::
  userParameterDouble () const
  {
    return this->userParameterDouble_;
  }

  userParameters::userParameterDouble_sequence& userParameters::
  userParameterDouble ()
  {
    return this->userParameterDouble_;
  }

  void userParameters::
  userParameterDouble (const userParameterDouble_sequence& s)
  {
    this->userParameterDouble_ = s;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ISMRMRD
{
  // subjectInformationType
  //

  subjectInformationType::
  subjectInformationType ()
  : ::xml_schema::type (),
    patientName_ (::xml_schema::flags (), this),
    patientWeight_kg_ (::xml_schema::flags (), this)
  {
  }

  subjectInformationType::
  subjectInformationType (const subjectInformationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    patientName_ (x.patientName_, f, this),
    patientWeight_kg_ (x.patientWeight_kg_, f, this)
  {
  }

  subjectInformationType::
  subjectInformationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    patientName_ (f, this),
    patientWeight_kg_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void subjectInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // patientName
      //
      if (n.name () == "patientName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientName_type > r (
          patientName_traits::create (i, f, this));

        if (!this->patientName_)
        {
          this->patientName_.set (r);
          continue;
        }
      }

      // patientWeight_kg
      //
      if (n.name () == "patientWeight_kg" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->patientWeight_kg_)
        {
          this->patientWeight_kg_.set (patientWeight_kg_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  subjectInformationType* subjectInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subjectInformationType (*this, f, c);
  }

  subjectInformationType::
  ~subjectInformationType ()
  {
  }

  // experimentalConditionsType
  //

  experimentalConditionsType::
  experimentalConditionsType (const H1resonanceFrequencyHz_type& H1resonanceFrequencyHz)
  : ::xml_schema::type (),
    H1resonanceFrequencyHz_ (H1resonanceFrequencyHz, ::xml_schema::flags (), this)
  {
  }

  experimentalConditionsType::
  experimentalConditionsType (const experimentalConditionsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    H1resonanceFrequencyHz_ (x.H1resonanceFrequencyHz_, f, this)
  {
  }

  experimentalConditionsType::
  experimentalConditionsType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    H1resonanceFrequencyHz_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void experimentalConditionsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // H1resonanceFrequencyHz
      //
      if (n.name () == "H1resonanceFrequencyHz" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!H1resonanceFrequencyHz_.present ())
        {
          this->H1resonanceFrequencyHz_.set (H1resonanceFrequencyHz_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!H1resonanceFrequencyHz_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "H1resonanceFrequencyHz",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  experimentalConditionsType* experimentalConditionsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class experimentalConditionsType (*this, f, c);
  }

  experimentalConditionsType::
  ~experimentalConditionsType ()
  {
  }

  // acquisitionSystemInformationType
  //

  acquisitionSystemInformationType::
  acquisitionSystemInformationType ()
  : ::xml_schema::type (),
    systemVendor_ (::xml_schema::flags (), this),
    systemModel_ (::xml_schema::flags (), this),
    systemFieldStrength_T_ (::xml_schema::flags (), this)
  {
  }

  acquisitionSystemInformationType::
  acquisitionSystemInformationType (const acquisitionSystemInformationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    systemVendor_ (x.systemVendor_, f, this),
    systemModel_ (x.systemModel_, f, this),
    systemFieldStrength_T_ (x.systemFieldStrength_T_, f, this)
  {
  }

  acquisitionSystemInformationType::
  acquisitionSystemInformationType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    systemVendor_ (f, this),
    systemModel_ (f, this),
    systemFieldStrength_T_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void acquisitionSystemInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // systemVendor
      //
      if (n.name () == "systemVendor" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< systemVendor_type > r (
          systemVendor_traits::create (i, f, this));

        if (!this->systemVendor_)
        {
          this->systemVendor_.set (r);
          continue;
        }
      }

      // systemModel
      //
      if (n.name () == "systemModel" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< systemModel_type > r (
          systemModel_traits::create (i, f, this));

        if (!this->systemModel_)
        {
          this->systemModel_.set (r);
          continue;
        }
      }

      // systemFieldStrength_T
      //
      if (n.name () == "systemFieldStrength_T" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->systemFieldStrength_T_)
        {
          this->systemFieldStrength_T_.set (systemFieldStrength_T_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }
  }

  acquisitionSystemInformationType* acquisitionSystemInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class acquisitionSystemInformationType (*this, f, c);
  }

  acquisitionSystemInformationType::
  ~acquisitionSystemInformationType ()
  {
  }

  // encodingSpaceType
  //

  encodingSpaceType::
  encodingSpaceType (const matrixSize_type& matrixSize,
                     const fieldOfView_m_type& fieldOfView_m)
  : ::xml_schema::type (),
    matrixSize_ (matrixSize, ::xml_schema::flags (), this),
    fieldOfView_m_ (fieldOfView_m, ::xml_schema::flags (), this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (::std::auto_ptr< matrixSize_type >& matrixSize,
                     ::std::auto_ptr< fieldOfView_m_type >& fieldOfView_m)
  : ::xml_schema::type (),
    matrixSize_ (matrixSize, ::xml_schema::flags (), this),
    fieldOfView_m_ (fieldOfView_m, ::xml_schema::flags (), this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (const encodingSpaceType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    matrixSize_ (x.matrixSize_, f, this),
    fieldOfView_m_ (x.fieldOfView_m_, f, this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    matrixSize_ (f, this),
    fieldOfView_m_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encodingSpaceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // matrixSize
      //
      if (n.name () == "matrixSize" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< matrixSize_type > r (
          matrixSize_traits::create (i, f, this));

        if (!matrixSize_.present ())
        {
          this->matrixSize_.set (r);
          continue;
        }
      }

      // fieldOfView_m
      //
      if (n.name () == "fieldOfView_m" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< fieldOfView_m_type > r (
          fieldOfView_m_traits::create (i, f, this));

        if (!fieldOfView_m_.present ())
        {
          this->fieldOfView_m_.set (r);
          continue;
        }
      }

      break;
    }

    if (!matrixSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "matrixSize",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!fieldOfView_m_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "fieldOfView_m",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  encodingSpaceType* encodingSpaceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingSpaceType (*this, f, c);
  }

  encodingSpaceType::
  ~encodingSpaceType ()
  {
  }

  // limitType
  //

  limitType::
  limitType (const minimum_type& minimum,
             const maximum_type& maximum,
             const center_type& center)
  : ::xml_schema::type (),
    minimum_ (minimum, ::xml_schema::flags (), this),
    maximum_ (maximum, ::xml_schema::flags (), this),
    center_ (center, ::xml_schema::flags (), this)
  {
  }

  limitType::
  limitType (const limitType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minimum_ (x.minimum_, f, this),
    maximum_ (x.maximum_, f, this),
    center_ (x.center_, f, this)
  {
  }

  limitType::
  limitType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minimum_ (f, this),
    maximum_ (f, this),
    center_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void limitType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // minimum
      //
      if (n.name () == "minimum" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!minimum_.present ())
        {
          this->minimum_.set (minimum_traits::create (i, f, this));
          continue;
        }
      }

      // maximum
      //
      if (n.name () == "maximum" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!maximum_.present ())
        {
          this->maximum_.set (maximum_traits::create (i, f, this));
          continue;
        }
      }

      // center
      //
      if (n.name () == "center" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!center_.present ())
        {
          this->center_.set (center_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!minimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimum",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!maximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maximum",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!center_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "center",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  limitType* limitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class limitType (*this, f, c);
  }

  limitType::
  ~limitType ()
  {
  }

  // encodingLimitsType
  //

  encodingLimitsType::
  encodingLimitsType ()
  : ::xml_schema::type (),
    kspace_encoding_step_1_ (::xml_schema::flags (), this),
    kspace_encoding_step_2_ (::xml_schema::flags (), this),
    average_ (::xml_schema::flags (), this),
    slice_ (::xml_schema::flags (), this),
    contrast_ (::xml_schema::flags (), this),
    phase_ (::xml_schema::flags (), this),
    repetition_ (::xml_schema::flags (), this),
    set_ (::xml_schema::flags (), this),
    segment_ (::xml_schema::flags (), this)
  {
  }

  encodingLimitsType::
  encodingLimitsType (const encodingLimitsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    kspace_encoding_step_1_ (x.kspace_encoding_step_1_, f, this),
    kspace_encoding_step_2_ (x.kspace_encoding_step_2_, f, this),
    average_ (x.average_, f, this),
    slice_ (x.slice_, f, this),
    contrast_ (x.contrast_, f, this),
    phase_ (x.phase_, f, this),
    repetition_ (x.repetition_, f, this),
    set_ (x.set_, f, this),
    segment_ (x.segment_, f, this)
  {
  }

  encodingLimitsType::
  encodingLimitsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    kspace_encoding_step_1_ (f, this),
    kspace_encoding_step_2_ (f, this),
    average_ (f, this),
    slice_ (f, this),
    contrast_ (f, this),
    phase_ (f, this),
    repetition_ (f, this),
    set_ (f, this),
    segment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encodingLimitsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // kspace_encoding_step_1
      //
      if (n.name () == "kspace_encoding_step_1" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< kspace_encoding_step_1_type > r (
          kspace_encoding_step_1_traits::create (i, f, this));

        if (!this->kspace_encoding_step_1_)
        {
          this->kspace_encoding_step_1_.set (r);
          continue;
        }
      }

      // kspace_encoding_step_2
      //
      if (n.name () == "kspace_encoding_step_2" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< kspace_encoding_step_2_type > r (
          kspace_encoding_step_2_traits::create (i, f, this));

        if (!this->kspace_encoding_step_2_)
        {
          this->kspace_encoding_step_2_.set (r);
          continue;
        }
      }

      // average
      //
      if (n.name () == "average" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< average_type > r (
          average_traits::create (i, f, this));

        if (!this->average_)
        {
          this->average_.set (r);
          continue;
        }
      }

      // slice
      //
      if (n.name () == "slice" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< slice_type > r (
          slice_traits::create (i, f, this));

        if (!this->slice_)
        {
          this->slice_.set (r);
          continue;
        }
      }

      // contrast
      //
      if (n.name () == "contrast" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< contrast_type > r (
          contrast_traits::create (i, f, this));

        if (!this->contrast_)
        {
          this->contrast_.set (r);
          continue;
        }
      }

      // phase
      //
      if (n.name () == "phase" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< phase_type > r (
          phase_traits::create (i, f, this));

        if (!this->phase_)
        {
          this->phase_.set (r);
          continue;
        }
      }

      // repetition
      //
      if (n.name () == "repetition" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< repetition_type > r (
          repetition_traits::create (i, f, this));

        if (!this->repetition_)
        {
          this->repetition_.set (r);
          continue;
        }
      }

      // set
      //
      if (n.name () == "set" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< set_type > r (
          set_traits::create (i, f, this));

        if (!this->set_)
        {
          this->set_.set (r);
          continue;
        }
      }

      // segment
      //
      if (n.name () == "segment" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< segment_type > r (
          segment_traits::create (i, f, this));

        if (!this->segment_)
        {
          this->segment_.set (r);
          continue;
        }
      }

      break;
    }
  }

  encodingLimitsType* encodingLimitsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingLimitsType (*this, f, c);
  }

  encodingLimitsType::
  ~encodingLimitsType ()
  {
  }

  // trajectoryType
  //

  trajectoryType::
  trajectoryType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType::
  trajectoryType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType::
  trajectoryType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType* trajectoryType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class trajectoryType (*this, f, c);
  }

  trajectoryType::value trajectoryType::
  _xsd_trajectoryType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_trajectoryType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_trajectoryType_indexes_,
                      _xsd_trajectoryType_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_trajectoryType_indexes_ + 6 || _xsd_trajectoryType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const trajectoryType::
  _xsd_trajectoryType_literals_[6] =
  {
    "cartesian",
    "epi",
    "radial",
    "goldenangle",
    "spiral",
    "other"
  };

  const trajectoryType::value trajectoryType::
  _xsd_trajectoryType_indexes_[6] =
  {
    ::ISMRMRD::trajectoryType::cartesian,
    ::ISMRMRD::trajectoryType::epi,
    ::ISMRMRD::trajectoryType::goldenangle,
    ::ISMRMRD::trajectoryType::other,
    ::ISMRMRD::trajectoryType::radial,
    ::ISMRMRD::trajectoryType::spiral
  };

  // userParameterLongType
  //

  userParameterLongType::
  userParameterLongType (const name_type& name,
                         const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterLongType::
  userParameterLongType (const userParameterLongType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterLongType::
  userParameterLongType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterLongType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterLongType* userParameterLongType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterLongType (*this, f, c);
  }

  userParameterLongType::
  ~userParameterLongType ()
  {
  }

  // userParameterDoubleType
  //

  userParameterDoubleType::
  userParameterDoubleType (const name_type& name,
                           const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterDoubleType::
  userParameterDoubleType (const userParameterDoubleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterDoubleType::
  userParameterDoubleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterDoubleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterDoubleType* userParameterDoubleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterDoubleType (*this, f, c);
  }

  userParameterDoubleType::
  ~userParameterDoubleType ()
  {
  }

  // ismrmrdHeader
  //

  ismrmrdHeader::
  ismrmrdHeader (const experimentalConditions_type& experimentalConditions)
  : ::xml_schema::type (),
    subjectInformation_ (::xml_schema::flags (), this),
    acquisitionSystemInformation_ (::xml_schema::flags (), this),
    experimentalConditions_ (experimentalConditions, ::xml_schema::flags (), this),
    encoding_ (::xml_schema::flags (), this),
    userParameters_ (::xml_schema::flags (), this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (::std::auto_ptr< experimentalConditions_type >& experimentalConditions)
  : ::xml_schema::type (),
    subjectInformation_ (::xml_schema::flags (), this),
    acquisitionSystemInformation_ (::xml_schema::flags (), this),
    experimentalConditions_ (experimentalConditions, ::xml_schema::flags (), this),
    encoding_ (::xml_schema::flags (), this),
    userParameters_ (::xml_schema::flags (), this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (const ismrmrdHeader& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subjectInformation_ (x.subjectInformation_, f, this),
    acquisitionSystemInformation_ (x.acquisitionSystemInformation_, f, this),
    experimentalConditions_ (x.experimentalConditions_, f, this),
    encoding_ (x.encoding_, f, this),
    userParameters_ (x.userParameters_, f, this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subjectInformation_ (f, this),
    acquisitionSystemInformation_ (f, this),
    experimentalConditions_ (f, this),
    encoding_ (f, this),
    userParameters_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ismrmrdHeader::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subjectInformation
      //
      if (n.name () == "subjectInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< subjectInformation_type > r (
          subjectInformation_traits::create (i, f, this));

        if (!this->subjectInformation_)
        {
          this->subjectInformation_.set (r);
          continue;
        }
      }

      // acquisitionSystemInformation
      //
      if (n.name () == "acquisitionSystemInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< acquisitionSystemInformation_type > r (
          acquisitionSystemInformation_traits::create (i, f, this));

        if (!this->acquisitionSystemInformation_)
        {
          this->acquisitionSystemInformation_.set (r);
          continue;
        }
      }

      // experimentalConditions
      //
      if (n.name () == "experimentalConditions" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< experimentalConditions_type > r (
          experimentalConditions_traits::create (i, f, this));

        if (!experimentalConditions_.present ())
        {
          this->experimentalConditions_.set (r);
          continue;
        }
      }

      // encoding
      //
      if (n.name () == "encoding" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.push_back (r);
        continue;
      }

      // userParameters
      //
      if (n.name () == "userParameters" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameters_type > r (
          userParameters_traits::create (i, f, this));

        if (!this->userParameters_)
        {
          this->userParameters_.set (r);
          continue;
        }
      }

      break;
    }

    if (!experimentalConditions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "experimentalConditions",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  ismrmrdHeader* ismrmrdHeader::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ismrmrdHeader (*this, f, c);
  }

  ismrmrdHeader::
  ~ismrmrdHeader ()
  {
  }

  // matrixSize
  //

  matrixSize::
  matrixSize (const x_type& x,
              const y_type& y,
              const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  matrixSize::
  matrixSize (const matrixSize& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  matrixSize::
  matrixSize (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void matrixSize::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!z_.present ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  matrixSize* matrixSize::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrixSize (*this, f, c);
  }

  matrixSize::
  ~matrixSize ()
  {
  }

  // fieldOfView_m
  //

  fieldOfView_m::
  fieldOfView_m (const x_type& x,
                 const y_type& y,
                 const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  fieldOfView_m::
  fieldOfView_m (const fieldOfView_m& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  fieldOfView_m::
  fieldOfView_m (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void fieldOfView_m::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!z_.present ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  fieldOfView_m* fieldOfView_m::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fieldOfView_m (*this, f, c);
  }

  fieldOfView_m::
  ~fieldOfView_m ()
  {
  }

  // encoding
  //

  encoding::
  encoding (const encodedSpace_type& encodedSpace,
            const reconSpace_type& reconSpace,
            const encodingLimits_type& encodingLimits,
            const trajectory_type& trajectory)
  : ::xml_schema::type (),
    encodedSpace_ (encodedSpace, ::xml_schema::flags (), this),
    reconSpace_ (reconSpace, ::xml_schema::flags (), this),
    encodingLimits_ (encodingLimits, ::xml_schema::flags (), this),
    trajectory_ (trajectory, ::xml_schema::flags (), this)
  {
  }

  encoding::
  encoding (::std::auto_ptr< encodedSpace_type >& encodedSpace,
            ::std::auto_ptr< reconSpace_type >& reconSpace,
            ::std::auto_ptr< encodingLimits_type >& encodingLimits,
            const trajectory_type& trajectory)
  : ::xml_schema::type (),
    encodedSpace_ (encodedSpace, ::xml_schema::flags (), this),
    reconSpace_ (reconSpace, ::xml_schema::flags (), this),
    encodingLimits_ (encodingLimits, ::xml_schema::flags (), this),
    trajectory_ (trajectory, ::xml_schema::flags (), this)
  {
  }

  encoding::
  encoding (const encoding& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    encodedSpace_ (x.encodedSpace_, f, this),
    reconSpace_ (x.reconSpace_, f, this),
    encodingLimits_ (x.encodingLimits_, f, this),
    trajectory_ (x.trajectory_, f, this)
  {
  }

  encoding::
  encoding (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    encodedSpace_ (f, this),
    reconSpace_ (f, this),
    encodingLimits_ (f, this),
    trajectory_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // encodedSpace
      //
      if (n.name () == "encodedSpace" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encodedSpace_type > r (
          encodedSpace_traits::create (i, f, this));

        if (!encodedSpace_.present ())
        {
          this->encodedSpace_.set (r);
          continue;
        }
      }

      // reconSpace
      //
      if (n.name () == "reconSpace" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< reconSpace_type > r (
          reconSpace_traits::create (i, f, this));

        if (!reconSpace_.present ())
        {
          this->reconSpace_.set (r);
          continue;
        }
      }

      // encodingLimits
      //
      if (n.name () == "encodingLimits" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encodingLimits_type > r (
          encodingLimits_traits::create (i, f, this));

        if (!encodingLimits_.present ())
        {
          this->encodingLimits_.set (r);
          continue;
        }
      }

      // trajectory
      //
      if (n.name () == "trajectory" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< trajectory_type > r (
          trajectory_traits::create (i, f, this));

        if (!trajectory_.present ())
        {
          this->trajectory_.set (r);
          continue;
        }
      }

      break;
    }

    if (!encodedSpace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "encodedSpace",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!reconSpace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reconSpace",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!encodingLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "encodingLimits",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!trajectory_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trajectory",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  encoding* encoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encoding (*this, f, c);
  }

  encoding::
  ~encoding ()
  {
  }

  // userParameters
  //

  userParameters::
  userParameters ()
  : ::xml_schema::type (),
    userParameterLong_ (::xml_schema::flags (), this),
    userParameterDouble_ (::xml_schema::flags (), this)
  {
  }

  userParameters::
  userParameters (const userParameters& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    userParameterLong_ (x.userParameterLong_, f, this),
    userParameterDouble_ (x.userParameterDouble_, f, this)
  {
  }

  userParameters::
  userParameters (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    userParameterLong_ (f, this),
    userParameterDouble_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // userParameterLong
      //
      if (n.name () == "userParameterLong" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterLong_type > r (
          userParameterLong_traits::create (i, f, this));

        this->userParameterLong_.push_back (r);
        continue;
      }

      // userParameterDouble
      //
      if (n.name () == "userParameterDouble" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterDouble_type > r (
          userParameterDouble_traits::create (i, f, this));

        this->userParameterDouble_.push_back (r);
        continue;
      }

      break;
    }
  }

  userParameters* userParameters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameters (*this, f, c);
  }

  userParameters::
  ~userParameters ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ISMRMRD
{
  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::ISMRMRD::ismrmrdHeader_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::xsd::cxx::tree::traits< ::ISMRMRD::ismrmrdHeader, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ismrmrdHeader",
      "http://www.ismrm.org/ISMRMRD");
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::xsd::cxx::tree::traits< ::ISMRMRD::ismrmrdHeader, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ismrmrdHeader",
      "http://www.ismrm.org/ISMRMRD");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace ISMRMRD
{
  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::DOMDocument& d,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ismrmrdHeader",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ismrmrdHeader_ (const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ismrmrdHeader",
        "http://www.ismrm.org/ISMRMRD",
        m, f));

    ::ISMRMRD::ismrmrdHeader_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const subjectInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // patientName
    //
    if (i.patientName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientName ();
    }

    // patientWeight_kg
    //
    if (i.patientWeight_kg ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientWeight_kg",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientWeight_kg ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const experimentalConditionsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // H1resonanceFrequencyHz
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "H1resonanceFrequencyHz",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.H1resonanceFrequencyHz ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const acquisitionSystemInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // systemVendor
    //
    if (i.systemVendor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemVendor",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemVendor ();
    }

    // systemModel
    //
    if (i.systemModel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemModel",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemModel ();
    }

    // systemFieldStrength_T
    //
    if (i.systemFieldStrength_T ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemFieldStrength_T",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemFieldStrength_T ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encodingSpaceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // matrixSize
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrixSize",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.matrixSize ();
    }

    // fieldOfView_m
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fieldOfView_m",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.fieldOfView_m ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const limitType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimum",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.minimum ();
    }

    // maximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximum",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.maximum ();
    }

    // center
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "center",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.center ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encodingLimitsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // kspace_encoding_step_1
    //
    if (i.kspace_encoding_step_1 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_1",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.kspace_encoding_step_1 ();
    }

    // kspace_encoding_step_2
    //
    if (i.kspace_encoding_step_2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_2",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.kspace_encoding_step_2 ();
    }

    // average
    //
    if (i.average ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "average",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.average ();
    }

    // slice
    //
    if (i.slice ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "slice",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.slice ();
    }

    // contrast
    //
    if (i.contrast ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contrast",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.contrast ();
    }

    // phase
    //
    if (i.phase ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "phase",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.phase ();
    }

    // repetition
    //
    if (i.repetition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "repetition",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.repetition ();
    }

    // set
    //
    if (i.set ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "set",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.set ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "segment",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.segment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const trajectoryType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const trajectoryType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const trajectoryType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterLongType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterDoubleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << ::xml_schema::as_double(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const ismrmrdHeader& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subjectInformation
    //
    if (i.subjectInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.subjectInformation ();
    }

    // acquisitionSystemInformation
    //
    if (i.acquisitionSystemInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "acquisitionSystemInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.acquisitionSystemInformation ();
    }

    // experimentalConditions
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "experimentalConditions",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.experimentalConditions ();
    }

    // encoding
    //
    for (ismrmrdHeader::encoding_const_iterator
         b (i.encoding ().begin ()), n (i.encoding ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encoding",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameters
    //
    if (i.userParameters ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameters",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.userParameters ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const matrixSize& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const fieldOfView_m& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // encodedSpace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encodedSpace",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.encodedSpace ();
    }

    // reconSpace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reconSpace",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.reconSpace ();
    }

    // encodingLimits
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encodingLimits",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.encodingLimits ();
    }

    // trajectory
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trajectory",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.trajectory ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameters& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // userParameterLong
    //
    for (userParameters::userParameterLong_const_iterator
         b (i.userParameterLong ().begin ()), n (i.userParameterLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterLong",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameterDouble
    //
    for (userParameters::userParameterDouble_const_iterator
         b (i.userParameterDouble ().begin ()), n (i.userParameterDouble ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterDouble",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

