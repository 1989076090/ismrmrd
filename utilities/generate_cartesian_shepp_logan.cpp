/*
 * generate_cartesian_shepp_logan.cpp
 *
 *  Created on: Apr 1, 2013
 *      Author: Michael S. Hansen
 *
 */

#include <iostream>
#include "ismrmrd_phantom.h"
#include "ismrmrd_hdf5.h"
#include "ismrmrd_fftw.h"
#include "ismrmrd.hxx"


using namespace ISMRMRD;

int main(int argc, char** argv)
{
	std::cout << "Generating Cartesian Shepp Logan Phantom" << std::endl;

	unsigned int matrix_size = 256; //Matrix size
	unsigned int ncoils = 8;        //Number of coils
	unsigned int ros = 2;           //Readout ovesampling
	unsigned int repetitions = 10;
	float noise_level = 0.05;

	boost::shared_ptr<NDArrayContainer<std::complex<float> > > phantom = shepp_logan_phantom(matrix_size);
	boost::shared_ptr<NDArrayContainer<std::complex<float> > > coils = generate_birdcage_sensititivies(matrix_size, ncoils, 1.5);

	std::vector<unsigned int> dims;
	dims.push_back(matrix_size*ros); //oversampling in the readout direction
	dims.push_back(matrix_size);
	dims.push_back(ncoils);

	NDArrayContainer<std::complex<float> > coil_images(dims);
	coil_images.data_ = std::complex<float>(0.0,0.0);

	for (unsigned int c = 0; c < ncoils; c++) {
		for (unsigned int y = 0; y < matrix_size; y++) {
			for (unsigned int x = 0; x < matrix_size; x++) {
				size_t out_index = c*matrix_size*matrix_size*ros + y*matrix_size*ros + ((matrix_size*ros-matrix_size)>>1) + x;
				size_t cindex = c*matrix_size*matrix_size + y*matrix_size + x;
				size_t iindex = y*matrix_size + x;
				coil_images.data_[out_index] = phantom->data_[iindex] * coils->data_[cindex];
			}
		}
	}


	//Let's append the data to the file
	IsmrmrdDataset d("testdata.h5","dataset");
	Acquisition acq;
	acq.setActiveChannels(ncoils);
	acq.setAvailableChannels(ncoils);
	size_t readout = matrix_size*ros;
	acq.setNumberOfSamples(readout);
	acq.setCenterSample(readout>>1);

	for (unsigned int r = 0; r < repetitions; r++) {
		NDArrayContainer<std::complex<float> > cm = coil_images;
		fft2c(cm);
		add_noise(cm,noise_level);
		for (unsigned int i = 0; i < matrix_size; i++) {
			acq.setFlags(0);

			//Set some flags
			if (i == 0) {
				acq.setFlag(ISMRMRD::FlagBit(ISMRMRD::ACQ_FIRST_IN_SLICE));
			}
			if (i == (matrix_size-1)) {
				acq.setFlag(ISMRMRD::FlagBit(ISMRMRD::ACQ_LAST_IN_SLICE));
			}
			acq.getIdx().kspace_encode_step_1 = i;
			acq.getIdx().repetition = r;
			acq.setSampleTimeUs(5.0);
			for (unsigned int c = 0; c < ncoils; c++) {
				memcpy(&acq[c*readout*2],&(cm.data_[c*matrix_size*readout + i*readout]),sizeof(float)*readout*2);
			}
			d.appendAcquisition(&acq);
		}
	}

	//Let's create a header, we will use the C++ class generated by XSD
	ISMRMRD::experimentalConditionsType exp(63500000); //~1.5T
	ISMRMRD::ismrmrdHeader h(exp);

	//Create an encoding section
	ISMRMRD::encodingSpaceType es(ISMRMRD::matrixSize(readout,matrix_size,1),ISMRMRD::fieldOfView_mm(600,300,6));
	ISMRMRD::encodingSpaceType rs(ISMRMRD::matrixSize((readout>>1),matrix_size,1),ISMRMRD::fieldOfView_mm(300,300,6));
	ISMRMRD::encodingLimitsType el;
	el.kspace_encoding_step_1(ISMRMRD::limitType(0,matrix_size-1,(matrix_size>>1)));
	ISMRMRD::encoding e(es,rs,el,ISMRMRD::trajectoryType::cartesian);

	//Add the encoding section to the header
	h.encoding().push_back(e);

	//Add any additional fields that you may want would go here....

	//e.g. parallel imaging
	//ISMRMRD::parallelImagingType parallel(ISMRMRD::accelerationFactorType(2,1));
	//parallel.calibrationMode(ISMRMRD::calibrationModeType::embedded);
    //h.parallelImaging(parallel);

	//Serialize the header
	xml_schema::namespace_infomap map;
	map[""].name = "http://www.ismrm.org/ISMRMRD";
	map[""].schema = "ismrmrd.xsd";
	std::stringstream str;
	ISMRMRD::ismrmrdHeader_(str, h, map);
	std::string xml_header = str.str();

	//Write the header to the data file.
	d.writeHeader(xml_header);


	d.appendArray(*phantom,"phantom");
	d.appendArray(*coils,"csm");
	d.appendArray(coil_images,"coil_images");

	return 0;
}




