<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/" />
<title>ISMRM Raw Data Format (ISMRMRD)</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="ismrm-raw-data-format-ismrmrd">
<h1 class="title">ISMRM Raw Data Format (ISMRMRD)</h1>

<div class="section" id="preamble">
<h1>Preamble</h1>
<p>A prerequisite for sharing magnetic resonance (imaging) reconstruction algorithms and code is a common raw data format. This document describes such a common raw data format and attempts to capture the data fields that are require to describe enough details about the magnetic resonance experiment to reconstruct images from the data.</p>
<p>This standard was developed by a subcommittee of the ISMRM Sedona 2013 workshop. Comments and requests for additions/modifications can be sent to:</p>
<ul class="simple">
<li>Michael S. Hansen (michael.hansen AT nih DOT gov)</li>
<li>Wally Block (wblock AT cae DOT wisc DOT edu)</li>
<li>Mark Griswold (mag46 AT case DOT edu)</li>
<li>Brian Hargreaves (bah AT stanford DOT edu)</li>
<li>Peter Boernert (peter.boernert AT philips DOT com)</li>
<li>Jim Pipe (Jim.Pipe AT DignityHealth DOT org)</li>
</ul>
<p>The source code, examples, and example datasets can be found on the ISMRM Raw Data Sourceforge <a class="reference external" href="http://sourceforge.net/projects/ismrmrd">website</a>.</p>
<p>To download the source code, clone the git archive:</p>
<pre class="literal-block">
git clone git://git.code.sf.net/p/ismrmrd/code ismrmrd-code
</pre>
</div>
<div class="section" id="change-log">
<h1>Change log</h1>
<p>August 2012 - First draft.</p>
</div>
<div class="section" id="overview">
<h1>Overview</h1>
<p>The raw data format combines a mix of flexible data structures (XML header) and fixed structures (equivalent to C-structs). A raw data set consist of 2 sections:</p>
<ol class="arabic simple">
<li>A flexible XML format document that can contain an arbitrary number of fields and accommodate everything from simple values (b-values, etc.) to entire vendor protocols, etc. This purpose of this XML document is to provide parameters that may be meaningful for some experiments but not for others. This XML format is defined by an XML Schema Definition file (ismrmrd.xsd).</li>
<li>Raw data section. This section contains all the acquired data in the experiment. Each data item is preceded by a C-struct with encoding numbers, etc. Following this data header is a channel header and data for each acquired channel. The raw data headers are defined in a C/C++ header file (ismrmrd.h)</li>
</ol>
<div class="section" id="flexible-data-header">
<h2>Flexible Data Header</h2>
<p>The flexible data structure is defined by the xml schema definition in <tt class="docutils literal">schema/ismrmrd.xsd</tt> (<a class="reference internal" href="#schema">schema</a> is included in appendix below).</p>
<p>An example of an XML file for a Cartesian 3D acquisition could look like:</p>
<pre class="literal-block">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;ismrmrdHeader xmlns=&quot;http://www.ismrm.org/ISMRMRD&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; xsi:schemaLocation=&quot;http://www.ismrm.org/ISMRMRD ismrmrd.xsd&quot;&gt;
  &lt;subjectInformation&gt;
    &lt;patientName&gt;phantom&lt;/patientName&gt;
    &lt;patientWeight_kg&gt;70.3068&lt;/patientWeight_kg&gt;
  &lt;/subjectInformation&gt;
  &lt;acquisitionSystemInformation&gt;
    &lt;systemVendor&gt;SIEMENS&lt;/systemVendor&gt;
    &lt;systemModel&gt;Avanto&lt;/systemModel&gt;
    &lt;systemFieldStrength_T&gt;1.494&lt;/systemFieldStrength_T&gt;
    &lt;receiverChannels&gt;32&lt;/receiverChannels&gt;
  &lt;/acquisitionSystemInformation&gt;
  &lt;experimentalConditions&gt;
    &lt;H1resonanceFrequency_Hz&gt;63642459&lt;/H1resonanceFrequency_Hz&gt;
  &lt;/experimentalConditions&gt;
  &lt;encoding&gt;
    &lt;trajectory&gt;cartesian&lt;/trajectory&gt;
    &lt;encodedSpace&gt;
      &lt;matrixSize&gt;
        &lt;x&gt;256&lt;/x&gt;
        &lt;y&gt;140&lt;/y&gt;
        &lt;z&gt;80&lt;/z&gt;
      &lt;/matrixSize&gt;
      &lt;fieldOfView_mm&gt;
        &lt;x&gt;600&lt;/x&gt;
        &lt;y&gt;328.153125&lt;/y&gt;
        &lt;z&gt;160&lt;/z&gt;
      &lt;/fieldOfView_mm&gt;
    &lt;/encodedSpace&gt;
    &lt;reconSpace&gt;
      &lt;matrixSize&gt;
        &lt;x&gt;128&lt;/x&gt;
        &lt;y&gt;116&lt;/y&gt;
        &lt;z&gt;64&lt;/z&gt;
      &lt;/matrixSize&gt;
      &lt;fieldOfView_mm&gt;
        &lt;x&gt;300&lt;/x&gt;
        &lt;y&gt;271.875&lt;/y&gt;
        &lt;z&gt;128&lt;/z&gt;
      &lt;/fieldOfView_mm&gt;
    &lt;/reconSpace&gt;
    &lt;encodingLimits&gt;
      &lt;kspace_encoding_step_1&gt;
        &lt;minimum&gt;0&lt;/minimum&gt;
        &lt;maximum&gt;83&lt;/maximum&gt;
        &lt;center&gt;28&lt;/center&gt;
      &lt;/kspace_encoding_step_1&gt;
      &lt;kspace_encoding_step_2&gt;
        &lt;minimum&gt;0&lt;/minimum&gt;
        &lt;maximum&gt;45&lt;/maximum&gt;
        &lt;center&gt;20&lt;/center&gt;
      &lt;/kspace_encoding_step_2&gt;
      &lt;slice&gt;
        &lt;minimum&gt;0&lt;/minimum&gt;
        &lt;maximum&gt;0&lt;/maximum&gt;
        &lt;center&gt;0&lt;/center&gt;
      &lt;/slice&gt;
    &lt;/encodingLimits&gt;
  &lt;/encoding&gt;
  &lt;sequenceTiming&gt;
    &lt;TR&gt;4.6&lt;/TR&gt;
    &lt;TE&gt;2.35&lt;/TE&gt;
    &lt;TI&gt;300&lt;/TI&gt;
  &lt;/sequenceTiming&gt;
&lt;/ismrmrdHeader&gt;


</pre>
<p>The most critical elements for image reconstruction are contained in the <tt class="docutils literal">&lt;encoding&gt;</tt> section of the document, which describes the encoded spaced and also the target reconstructed space. Along with the <tt class="docutils literal">&lt;encodingLimits&gt;</tt> this section allows the reconstruction program to determine matrix sizes, oversampling factors, partial Fourier, etc. In the example above, data is acquired with two-fold oversampling in the read-out (<tt class="docutils literal">x</tt>) direction, which is reflected in the larger matrix size in the encoded space compared to the reconstruction space. The field of view is also twice as large in the encoded space. For the first phase encoding dimension (<tt class="docutils literal">y</tt>), we have a combination of oversampling (20%), reduced phase resolution (only 83 lines of k-space acquired, and partial Fourier sampling, which is reflected in the asymmetric center of the encoding limits of the <tt class="docutils literal">&lt;kspace_encoding_step_1&gt;</tt>. Specifically, the data lines would be placed into the encoding space like this:</p>
<pre class="literal-block">
0                                     70                                         139
|-------------------------------------|-------------------------------------------|
                      ****************************************************
                      ^               ^                                  ^
                      0              28                                  83
</pre>
<p>After FFT, only the central 116 lines are kept, i.e. there is a reduced field of view in the phase encoding direction. Center and encoding limits for the readout dimension is not given in the XML header. This is to accommodate sequences where the center of the readout may change from readout to readout (alternating directions of readout). There is a field on the individual data headers (see below) to indicate the center of the readout.</p>
<p>An experiment can have multiple encoding spaces and it is possible to indicate on each acquired data readout, which encoding space the data belongs to (see below).</p>
<p>In addition to the defined field in the xml header, it is possible to add an arbitrary number of user defined parameters to accommodate special sequence parameters. Please consult the xml <a class="reference internal" href="#schema">schema</a> to see how user parameters are defined. Briefly, the XML header can have a section at the end which looks like:</p>
<pre class="literal-block">
&lt;userParameters&gt;
  &lt;userParameterLong&gt;
    &lt;name&gt;MyVar1&lt;/name&gt;&lt;value&gt;1003&lt;/value&gt;
  &lt;/userParameterLong&gt;
  &lt;userParameterLong&gt;
    &lt;name&gt;MyVar2&lt;/name&gt;&lt;value&gt;1999&lt;/value&gt;
  &lt;/userParameterLong&gt;
  &lt;userParameterDouble&gt;
    &lt;name&gt;MyDoubleVar&lt;/name&gt;&lt;value&gt;87.6676&lt;/value&gt;
  &lt;/userParameterDouble&gt;
&lt;/userParameters&gt;
</pre>
</div>
<div class="section" id="fixed-data-structures">
<h2>Fixed Data structures</h2>
<p>Each acquisition is preceded by the following fixed layout structure:</p>
<pre class="literal-block">
 struct AcquisitionHeader
 {
   uint16_t           version;                        //First unsigned int indicates the version
   uint64_t           flags;                          //bit field with flags
   uint32_t           measurement_uid;                //Unique ID for the measurement
   uint32_t           scan_counter;                   //Current acquisition number in the measurement
   uint32_t           acquisition_time_stamp;         //Acquisition clock
   uint32_t           physiology_time_stamp[3];       //Physiology time stamps, e.g. ecg, breating, etc. 
   uint16_t           number_of_samples;              //Number of samples acquired
   uint16_t           available_channels;             //Available coils
   uint16_t           active_channels;                //Active coils on current acquisiton
   uint64_t           channel_mask[16];               //Mask to indicate which channels are active. Support for 1024 channels
   uint16_t           discard_pre;                    //Samples to be discarded at the beginning of acquisition
   uint16_t           discard_post;                   //Samples to be discarded at the end of acquisition
   uint16_t           center_sample;                  //Sample at the center of k-space
   uint16_t           encoding_space_ref;             //Reference to an encoding space, typically only one per acquisition
   uint16_t           trajectory_dimensions;          //Indicates the dimensionality of the trajectory vector (0 means no trajectory)
   float              sample_time_us;                 //Time between samples in micro seconds, sampling BW
   float              position[3];                    //Three-dimensional spatial offsets from isocenter
   float              quaternion[4];                  //Angulation of acquisition
   float              patient_table_position[3];      //Patient table off-center
   EncodingCounters   idx;                            //Encoding loop counters, see above
   int32_t            user_int[8];                    //Free user parameters
   float              user_float[8];                  //Free user parameters
 }; 

</pre>
<p>Where EncodingCounters are defined as:</p>
<pre class="literal-block">
  struct EncodingCounters {
    uint16_t kspace_encode_step_1; //e.g. phase encoding line number
    uint16_t kspace_encode_step_2; //e.g. partition encodning number
    uint16_t average;              //e.g. signal average number
    uint16_t slice;                //e.g. imaging slice number
    uint16_t contrast;             //e.g. echo number in multi-echo
    uint16_t phase;                //e.g. cardiac phase number
    uint16_t repetition;           //e.g. dynamic number for dynamic scanning
    uint16_t set;                  //e.g. flow encodning set
    uint16_t segment;              //e.g. segment number for segmented acquisition
    uint16_t user[8];              //Free user parameters
  };

</pre>
<p>The interpretation of some of these fields may vary from sequence to sequence, i.e. for a Cartesian sequence, <tt class="docutils literal">kspace_encode_step_1</tt> would be the phase encoding step, for a spiral sequence where phase encoding direction does not make sense, it would be the spiral interleave number. The <tt class="docutils literal">encoding_space_ref</tt> enables the user to tie an acquisition to a specific encoding space (see above) in case there are multiple, e.g. in situations where a calibration scan may be integrated in the acquisition.</p>
<p>The flags field is a bit mask, which in principle can be used freely by the user, but suggested flag values are given in <tt class="docutils literal">ismrmrd.h</tt>, it is recommended not to use already designated flag bits for custom purposes. There are a set of bits reserved for prototyping (bits 57-64), please see <tt class="docutils literal">ismrmrd.h</tt> for details.</p>
<p>The header contains a <tt class="docutils literal">trajectory_dimensions</tt> field. If the value of this field is larger than 0, it means that trajectories are stored with each individual acquisition. For a 2D acquisition, the <tt class="docutils literal">trajectory_dimensions</tt> would typically be 2 and the convention (for memory layout) is that the header is followed immediately by the trajectory before the complex data. There is an example of how this memory layout could be implemented with a C++ class in the <tt class="docutils literal">ismrmrd.h</tt> file:</p>
<pre class="literal-block">
class Acquisition
{

//....

AcquisitionHeader head_; //Header, see above

float* traj_;            //Trajectory, elements = head_.trajectory_dimensions*head_.number_of_samples
                         //   [kx,ky,kx,ky.....]        (for head_.trajectory_dimensions = 2)
                         //   [kx,ky,kz,kx,ky,kz,.....] (for head_.trajectory_dimensions = 3)

float* data_;            //Actual data, elements = head_.number_of_samples*head_.active_channels*2
                         //   [re,im,re,im,.....,re,im,re,im,.....,re,im,re,im,.....]
                         //    ---channel 1-------channel 2---------channel 3-----

};
</pre>
<p>This suggested memory layout is only a suggestion. The HDF5 interface (see below) can be used to read the data into many different data structures. In fact, the user can choose to read only part of the header or not read the data, etc.</p>
</div>
</div>
<div class="section" id="file-storage">
<h1>File Storage</h1>
<p>The ISMRM Raw Data format is stored in HDF5 format. Details on this format can be found at the <a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a> website. Briefly it is a hierarchical data format (much like a file system), which can contain multiple variable organized in groups (like folders in a file system). The variables can contain arrays of data values, custom defined structs, or simple text fields. It is the convention (but not a requirement) that the ISMRMRD datasets are stored in a group called <tt class="docutils literal">/dataset</tt>. The XML configuration is stored in the variable <tt class="docutils literal">/dataset/xml</tt> and the data is stored in <tt class="docutils literal">/dataset/data</tt>. HDF5 files can be viewed with the HDFView application which is available on the HDF5 website for multiple platforms. Files can also be read directly in Matlab, in fact Matlab uses (since file format v7.3) HDF5 as its internal data format in the <tt class="docutils literal">.mat</tt> files. As an example the data from an ISMRMRD file with name <tt class="docutils literal">myfile.h5</tt> can be read in matlab with a command like:</p>
<pre class="literal-block">
&gt;&gt; data = h5read('simple_gre.h5', '/dataset/data');
&gt;&gt; data

data =

head: [1x1 struct]
traj: {1x1281 cell}
data: {1x1281 cell}

 &gt;&gt; data.head

 ans =

                version: [1x1281 uint16]
                  flags: [1x1281 uint64]
        measurement_uid: [1x1281 uint32]
           scan_counter: [1x1281 uint32]
 acquisition_time_stamp: [1x1281 uint32]
  physiology_time_stamp: [3x1281 uint32]
      number_of_samples: [1x1281 uint16]
     available_channels: [1x1281 uint16]
        active_channels: [1x1281 uint16]
           channel_mask: [16x1281 uint64]
            discard_pre: [1x1281 uint16]
           discard_post: [1x1281 uint16]
          center_sample: [1x1281 uint16]
     encoding_space_ref: [1x1281 uint16]
  trajectory_dimensions: [1x1281 uint16]
         sample_time_us: [1x1281 single]
               position: [3x1281 single]
             quaternion: [4x1281 single]
 patient_table_position: [3x1281 single]
                    idx: [1x1 struct]
               user_int: [8x1281 int32]
             user_float: [8x1281 single]

 &gt;&gt;
</pre>
<p>The HDF5 file format can be access from C, C++, and java using the libraries provided on the HDF5 website. The ISMRMRD distribution also comes with some C++ wrappers that can be used for easy access (read and write) from C++ programs. See below.</p>
</div>
<div class="section" id="c-support-library">
<h1>C++ Support Library</h1>
<p>To enable easy prototyping of C++ software using the ISMRMRD data format, a simple C++ wrapper class is provided (defined in <tt class="docutils literal">ismrmrd_hdf5.h</tt>):</p>
<pre class="literal-block">
class EXPORTISMRMRD IsmrmrdDataset
{
 public:
         IsmrmrdDataset(const char* filename, const char* groupname, bool create_file_if_needed = true);
         int appendAcquisition(Acquisition* a);
         int writeHeader(std::string&amp; xml);

         boost::shared_ptr&lt;std::string&gt; readHeader();
         boost::shared_ptr&lt;Acquisition&gt; readAcquisition(unsigned long index = 0);
         unsigned long getNumberOfAcquisitions();
 };
</pre>
<p>Using this wrapper, C++ applications can be programmed as:</p>
<pre class="literal-block">
boost::shared_ptr&lt;ISMRMRD::IsmrmrdDataset&gt; ismrmrd_dataset(new ISMRMRD::IsmrmrdDataset(hdf5_in_data_file,hdf5_in_group));
boost::shared_ptr&lt;std::string&gt; xml_config = ismrmrd_dataset-&gt;readHeader();

//Do something with the header

unsigned long acquisitions = ismrmrd_dataset-&gt;getNumberOfAcquisitions();

for (unsigned long int i = 0; i &lt; acquisitions; i++) {
  boost::shared_ptr&lt;ISMRMRD::Acquisition&gt; acq_tmp = ismrmrd_dataset-&gt;readAcquisition(i);
  //Do something with the data
}
</pre>
<p>Since the XML part of the header is defined in the <tt class="docutils literal">schema/ismrmrd.xsd</tt> file, it is possible to use XML data binding tools such as CodeSynthesys XSD to generate a C++ class representation of the header for easy access to the fields. The <tt class="docutils literal">cmake</tt> build files that accompany the ISMRMRD distribution automatically tries to find CodeSynthesis XSD and generate such a binding. With the C++ representation of the header it can be parsed with something like:</p>
<pre class="literal-block">
xml_schema::properties props;
props.schema_location (&quot;http://www.ismrm.org/ISMRMRD&quot;,std::string(&quot;/full/path/to/ismrmrd.xsd&quot;));
std::istringstream str_stream(xml, std::stringstream::in);
boost::shared_ptr&lt;ISMRMRD::ismrmrdHeader&gt; cfg;

try {
   cfg = boost::shared_ptr&lt;ISMRMRD::ismrmrdHeader&gt;(ISMRMRD::ismrmrdHeader_ (str_stream,0,props));
}  catch (const xml_schema::exception&amp; e) {
   std::cout &lt;&lt; &quot;Failed to parse XML Parameters: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
}

//Use the configuration, e.g.:
std::cout &lt;&lt; &quot;Number of encoding spaces: &quot; &lt;&lt; cfg-&gt;encoding().size() &lt;&lt; std::endl;
</pre>
<p>Again, this is not a requirement for using the ISMRMRD format, the XML can be parsed with numerous other xml parsing libraries. The schema file <tt class="docutils literal">schema/ismrmrd.xsd</tt> gives the user the option of validating the XML header before parsing, which is recommended to reduce the chance of hard to detect errors in your code due to missing or malformed parameters.</p>
</div>
<div class="section" id="matlab-example-code-and-datasets">
<h1>Matlab Example Code and Datasets</h1>
<p>The <tt class="docutils literal">examples</tt> folder contains some matlab code to illustrate simple interaction with the ISMRMRD data format. The examples use test data sets, wich can be downloaded from the Sourceforge <a class="reference external" href="http://sourceforge.net/projects/ismrmrd">website</a>. Go to the <tt class="docutils literal">examples/data</tt> folder and type the following to download the data:</p>
<pre class="literal-block">
wget https://sourceforge.net/projects/ismrmrd/files/data/3D_partial_fourier.h5
wget https://sourceforge.net/projects/ismrmrd/files/data/simple_gre.h5
wget https://sourceforge.net/projects/ismrmrd/files/data/simple_spiral.h5
</pre>
<p>For instance, to reconstruct a 2D Cartesian acquisition (10 image repetitions), type (from the <tt class="docutils literal">examples/matlab</tt> folder):</p>
<pre class="literal-block">
&gt;&gt; images = simple_cartesian_recon('../data/simple_gre.h5');
Reconstructing image 1....done
Reconstructing image 2....done
Reconstructing image 3....done
Reconstructing image 4....done
Reconstructing image 5....done
Reconstructing image 6....done
Reconstructing image 7....done
Reconstructing image 8....done
Reconstructing image 9....done
Reconstructing image 10....done
&gt;&gt;
</pre>
<p>You should see one of the reconstructed images display. An example is also given of a 3D acquisition with partial Fourier, phase and slice oversampling, etc. Reconstruct this dataset with:</p>
<pre class="literal-block">
&gt;&gt; images = simple_cartesian_recon('../data/3D_partial_fourier.h5');
Reconstructing image 1....done
</pre>
<p>The center slice of the volume should be displayed at the end of the reconstruction.</p>
<p>Finally, there is also a spiral dataset. This dataset illustrates how the flexible section of the <tt class="docutils literal">&lt;trajectoryDescription&gt;</tt> can be used to add user defined parameters and an identifier to describe the trajectory. This dataset is also an example of storing the trajectory with the data for direct reconstruction. Reconstruct this dataset with:</p>
<pre class="literal-block">
&gt;&gt; images = simple_spiral_recon('../data/simple_spiral.h5');
Reconstructing image 1....done
Reconstructing image 2....done
Reconstructing image 3....done
Reconstructing image 4....done
Reconstructing image 5....done
Reconstructing image 6....done
Reconstructing image 7....done
Reconstructing image 8....done
Reconstructing image 9....done
Reconstructing image 10....done
&gt;&gt;
</pre>
</div>
<div class="section" id="appendix">
<h1>Appendix</h1>
<div class="section" id="xml-schema-definition">
<h2>XML Schema Definition</h2>
<pre class="literal-block" id="schema">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;xs:schema xmlns=&quot;http://www.ismrm.org/ISMRMRD&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; elementFormDefault=&quot;qualified&quot; targetNamespace=&quot;http://www.ismrm.org/ISMRMRD&quot;&gt;

  &lt;xs:element name=&quot;ismrmrdHeader&quot;&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;subjectInformation&quot; type=&quot;subjectInformationType&quot;/&gt;
        &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;acquisitionSystemInformation&quot; type=&quot;acquisitionSystemInformationType&quot;/&gt; 
        &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;experimentalConditions&quot; type=&quot;experimentalConditionsType&quot;/&gt;
        &lt;xs:element maxOccurs=&quot;65535&quot; minOccurs=&quot;1&quot; name=&quot;encoding&quot;&gt;
          &lt;xs:complexType&gt;
            &lt;xs:all&gt;
              &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;encodedSpace&quot; type=&quot;encodingSpaceType&quot;/&gt;
              &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;reconSpace&quot; type=&quot;encodingSpaceType&quot;/&gt;
              &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;encodingLimits&quot; type=&quot;encodingLimitsType&quot;/&gt;
              &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;trajectory&quot; type=&quot;trajectoryType&quot;/&gt;
              &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;trajectoryDescription&quot; type=&quot;trajectoryDescriptionType&quot;/&gt;
            &lt;/xs:all&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
        &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;sequenceTiming&quot; type=&quot;sequenceTimingType&quot;/&gt;
        &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;userParameters&quot;&gt;
          &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
              &lt;xs:element maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot; name=&quot;userParameterLong&quot; type=&quot;userParameterLongType&quot;/&gt;
              &lt;xs:element maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot; name=&quot;userParameterDouble&quot; type=&quot;userParameterDoubleType&quot;/&gt;
            &lt;/xs:sequence&gt;
          &lt;/xs:complexType&gt;
        &lt;/xs:element&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name=&quot;subjectInformationType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;patientName&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;patientWeight_kg&quot; type=&quot;xs:float&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name=&quot;experimentalConditionsType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element name=&quot;H1resonanceFrequency_Hz&quot; type=&quot;xs:long&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;acquisitionSystemInformationType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;systemVendor&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;systemModel&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;systemFieldStrength_T&quot; type=&quot;xs:float&quot;/&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;relativeReceiverNoiseBandwidth&quot; type=&quot;xs:float&quot;/&gt;
      &lt;xs:element minOccurs=&quot;0&quot; name=&quot;receiverChannels&quot; type=&quot;xs:unsignedShort&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;encodingSpaceType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element name=&quot;matrixSize&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element default=&quot;1&quot; maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;x&quot; type=&quot;xs:unsignedShort&quot;/&gt;
            &lt;xs:element default=&quot;1&quot; maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;y&quot; type=&quot;xs:unsignedShort&quot;/&gt;
            &lt;xs:element default=&quot;1&quot; maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;z&quot; type=&quot;xs:unsignedShort&quot;/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
      &lt;xs:element name=&quot;fieldOfView_mm&quot;&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;x&quot; type=&quot;xs:float&quot;/&gt;
            &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;y&quot; type=&quot;xs:float&quot;/&gt;
            &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;z&quot; type=&quot;xs:float&quot;/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;limitType&quot;&gt;
    &lt;xs:all&gt; 
      &lt;xs:element default=&quot;0&quot; name=&quot;minimum&quot; type=&quot;xs:unsignedShort&quot;/&gt;
      &lt;xs:element default=&quot;0&quot; name=&quot;maximum&quot; type=&quot;xs:unsignedShort&quot;/&gt;
      &lt;xs:element default=&quot;0&quot; name=&quot;center&quot; type=&quot;xs:unsignedShort&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;encodingLimitsType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;kspace_encoding_step_0&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;kspace_encoding_step_1&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;kspace_encoding_step_2&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;average&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;slice&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;contrast&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;phase&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;repetition&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;set&quot; type=&quot;limitType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;segment&quot; type=&quot;limitType&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:simpleType name=&quot;trajectoryType&quot;&gt;
    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
      &lt;xs:enumeration value=&quot;cartesian&quot;/&gt;
      &lt;xs:enumeration value=&quot;epi&quot;/&gt;
      &lt;xs:enumeration value=&quot;radial&quot;/&gt;
      &lt;xs:enumeration value=&quot;goldenangle&quot;/&gt;
      &lt;xs:enumeration value=&quot;spiral&quot;/&gt;
      &lt;xs:enumeration value=&quot;other&quot;/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:complexType name=&quot;trajectoryDescriptionType&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot; name=&quot;identifier&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot; name=&quot;userParameterLong&quot; type=&quot;userParameterLongType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot; name=&quot;userParameterDouble&quot; type=&quot;userParameterDoubleType&quot;/&gt;
      &lt;xs:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot; name=&quot;comment&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;sequenceTimingType&quot;&gt;
        &lt;xs:sequence&gt;
                &lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot; type=&quot;xs:float&quot; name=&quot;TR&quot;/&gt;
                &lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot; type=&quot;xs:float&quot; name=&quot;TE&quot;/&gt;
                &lt;xs:element minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; type=&quot;xs:float&quot; name=&quot;TI&quot;/&gt;
        &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;userParameterLongType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;value&quot; type=&quot;xs:long&quot;/&gt; 
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name=&quot;userParameterDoubleType&quot;&gt;
    &lt;xs:all&gt;
      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;value&quot; type=&quot;xs:double&quot;/&gt; 
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

</pre>
</div>
</div>
</div>
</body>
</html>
